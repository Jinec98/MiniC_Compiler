/**
 * JJTree template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{  JDK_VERSION = "1.5";  static = true;}PARSER_BEGIN(EG2)package parser;import java.io.FileInputStream;import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.io.IOException;import util.*;public class EG2{  static QTList qtList = new QTList();  static ArgList argList = new ArgList();  static public ErrorList errorList = new ErrorList();
  static public String filePath = null;
  //static public EG2 parser = null;
  public static void run(EG2 parser)  {    //输出单词序列    try    {      Token token;      token = token_source.getNextToken();
      FileOutputStream out = new FileOutputStream("Lexical.txt");
      PrintStream p = new PrintStream(out);
      int innerId = 0;      while (token.image != "")      {
		innerId++;
        p.println(innerId + ":\t(" + token.image + ",\t" + token.kind + "\t)\n");
                //System.out.println("<" + token.image + ",\t" + token.kind + ">");        token = token_source.getNextToken();      }    }    catch (Exception e)    {      //System.out.println("Oops.");      //System.out.println(e.getMessage());
      errorList.addError(e.getMessage());    }
        //输入流重置
    FileInputStream fileInput = null;
    try    {      fileInput = new FileInputStream(filePath);    }    catch (FileNotFoundException e1)    {      // TODO Auto-generated catch block
      //e1.printStackTrace();
      String errorInfo = "Error: File can not found.";      errorList.addError(errorInfo);    }    parser.ReInit(fileInput);
        //输出语法树    try    {      SimpleNode n = EG2.Start();
      n.Init();      n.dump("",n.p);    }    catch (Exception e)    {      //System.out.println("Oops.");      //System.out.println(e.getMessage());
      errorList.addError(e.getMessage());    }
        //输出四元式
    qtList.Init();    qtList.printQTTable();
    qtList.clear();
    //输出符号表
    argList.Init();
    argList.printArgTable();
	argList.clear();
        //输出错误列表
    errorList.Init();
    errorList.printError();
    errorList.clear();  }}PARSER_END(EG2)SKIP :{  " "| "\t"| "\n"| "\r"| < "//" (~[ "\n", "\r" ])*    (      "\n"    | "\r"    | "\r\n"    ) >| < "/*" (~[ "*" ])* "*"    (      ~[ "/" ] (~[ "*" ])* "*"    )*    "/" >}TOKEN : /* LITERALS */{  < INTEGER_LITERAL :    < DECIMAL_LITERAL > ([ "l", "L" ])?  | < HEX_LITERAL > ([ "l", "L" ])?  | < OCTAL_LITERAL > ([ "l", "L" ])? >| < #DECIMAL_LITERAL : [ "1"-"9" ] ([ "0"-"9" ])* >| < #HEX_LITERAL : "0" [ "x", "X" ] ([ "0"-"9", "a"-"f", "A"-"F" ])+ >| < #OCTAL_LITERAL : "0" ([ "0"-"7" ])* >| < FLOAT_LITERAL :    (< INTEGER_LITERAL >)+    (      "." (< INTEGER_LITERAL >)+    )? >}TOKEN : /* KEYWORDS */{  < MAIN : "main" >| < VOID : "void" >| < INT : "int" >| < FLOAT : "float" >| < DOUBLE : "double" >| < IF : "if" >| < ELSE : "else" >| < DO : "do" >| < FOR : "for" >| < WHILE : "while" >| < SWITCH : "switch" >| < CASE : "case" >| < BREAK : "break" >| < DEFAULT1 : "default" >| < RETURN : "return" >}TOKEN : /* IDENTIFIERS */{  < IDENTIFIER :    < LETTER >    (      < LETTER >    | < DIGIT >    )* >| < #LETTER : [ "_", "a"-"z", "A"-"Z" ] >| < #DIGIT : [ "0"-"9" ] >}TOKEN : /* OPERATOR */{  < PLUS : "+" >| < MINUS : "-" >| < MULTIPLY : "*" >| < DIVIDE : "/" >| < MOD : "%" >| < EQUAL : "=" >}TOKEN : /* RELATION */{  < RELATION :    "<"  | "<="  | ">"  | ">="  | "=="  | "!=" >}TOKEN : /* LOGICAL */{  < AND : "&&" >| < OR : "||" >}TOKEN : /* SEPARATER */{  < SEMICOLON : ";" >| < COMMA : "," >| < LEFTBRACES : "{" >| < RIGHTBRACES : "}" >| < LEFTBRACKETS : "[" >| < RIGHTBRACKETS : "]" >| < LEFTPARENTHESES : "(" >| < RIGHTPARENTHESES : ")" >}SimpleNode Start() :{}{  Program() < EOF >  {    return jjtThis;  }}void Program() :{}{  (    < INT >  | < VOID >  )  < MAIN > "(" ")" "{"  (    StatementBlock()  )*  "}"}void StatementBlock() :{}{  Statement()| "{"  (    StatementBlock()  )*  "}"}void Statement() :{}{  SeqStatement()| ConStatement()| WhileStatement()| ForStatement()| DoWhileStatement()| SwitchCaseStatement()}void SeqStatement() :{}{  [    DeclareStatement()  | AssignStatement()  ]  ";"}void DeclareStatement() :{  Token t;  Token id;  ArgInfo arg;}{  (    t = < INT >  | t = < FLOAT >  | t = < DOUBLE >  )  id = < IDENTIFIER >  {    arg = new ArgInfo(t.image, id);    if (argList.checkRepeat(arg))    {      String errorInfo = "";      errorInfo += "Variable \"";      errorInfo += t.image;      errorInfo += " ";      errorInfo += id.image;      errorInfo += "\" declaration repeat at line ";      errorInfo += id.endLine;      errorInfo += ", column ";      errorInfo += id.endColumn;      errorInfo += ".";      errorList.addError(errorInfo);    }    else    {      argList.addArgInfo(arg);    }  }  (    "," id = < IDENTIFIER >    {      arg = new ArgInfo(t.image, id);      if (argList.checkRepeat(arg))      {        String errorInfo = "";        errorInfo += "Variable \"";        errorInfo += t.image;        errorInfo += " ";        errorInfo += id.image;        errorInfo += "\" declaration repeat at line ";        errorInfo += id.endLine;        errorInfo += ", column ";        errorInfo += id.endColumn;        errorInfo += ".";        errorList.addError(errorInfo);        errorList.addError(errorInfo);      }      else      {        argList.addArgInfo(arg);      }    }  )*}void AssignStatement() :{  Token id;  Token a;  String e;}{  id = < IDENTIFIER > a = < EQUAL > e = Expression()  {    if (argList.checkUndefined(id.image))    {      String errorInfo = "";      errorInfo += "Variable \"";      errorInfo += id.image;      errorInfo += "\" are not declared at line ";      errorInfo += id.endLine;      errorInfo += ", column ";      errorInfo += id.endColumn;      errorInfo += ".";      errorList.addError(errorInfo);    }    else    {      QTInfo qt = new QTInfo(a.image, e, "_", id.image);      qtList.addQTInfo(qt);    }  }}void ConStatement() :{  ConditionValue chain = null;  QTInfo info = null;}{  < IF > "(" chain = Logical()  {    chain.backpatchTrueChain(QTInfo.size + 1);  }  ")" StatementBlock()  (    LOOKAHEAD(1)    < ELSE >    {      info = new QTInfo("J", "_", "_", "WAIT");      qtList.addQTInfo(info);      chain.backpatchFalseChain(QTInfo.size + 1);    }    StatementBlock()  )?  {    if (info != null) info.setResult(QTInfo.size + 1);    else chain.backpatchFalseChain(QTInfo.size + 1);  }}void WhileStatement() :{  ConditionValue chain = null;  int quad;}{  < WHILE > "("  {    quad = QTInfo.size + 1;  }  chain = Logical()  {    chain.backpatchTrueChain(QTInfo.size + 1);  }  ")" StatementBlock()  {    qtList.addQTInfo(new QTInfo("J", "_", "_", quad));    chain.backpatchFalseChain(QTInfo.size + 1);  }}void ForStatement() :{  ConditionValue chain = null;  int quad1;  int quad2;}{  < FOR > "(" AssignStatement() ";"  {    quad1 = QTInfo.size + 1;  }  chain = Logical()  {    quad2 = QTInfo.size + 1;  }  ";" AssignStatement()  {    qtList.addQTInfo(new QTInfo("J", "_", "_", quad1));    chain.backpatchTrueChain(QTInfo.size + 1);  }  ")" StatementBlock()  {    qtList.addQTInfo(new QTInfo("J", "_", "_", quad2));    chain.backpatchFalseChain(QTInfo.size + 1);  }}void DoWhileStatement() :{  ConditionValue chain = null;  int quad;}{  < DO >  {    quad = QTInfo.size + 1;  }  StatementBlock() < WHILE > "(" chain = Logical()  {    chain.backpatchTrueChain(quad);    chain.backpatchFalseChain(QTInfo.size + 1);  }  ")" ";"}void SwitchCaseStatement() :{  String idStr;  String caseStr;  Token t = null;  Token bk = null;  Token mode = null;  QTInfo info = null;  QTInfo continueInfo = null;  ConditionValue breakChain = new ConditionValue();  int defaultQuad = 0;  boolean hasDefault = false;}{  < SWITCH > "(" idStr = Expression()  ")" "{"  (    (      mode = < CASE > t = < INTEGER_LITERAL >    | mode = < DEFAULT1 >    )    {      if (info != null) info.setResult(QTInfo.size + 1);      if (mode.image == "case")      {        if (continueInfo != null)        {          continueInfo.setResult(QTInfo.size + 3);          continueInfo = null;        }        caseStr = t.image;        qtList.addQTInfo(new QTInfo("J==", idStr, caseStr, QTInfo.size + 3));        info = new QTInfo("J", "_", "_", "WAIT");        qtList.addQTInfo(info);      }      else if (mode.image == "default")      {        if (hasDefault)        {          //error:
          String errorInfo = "";          errorInfo += "Multiple default labels in one switch at line ";          errorInfo += mode.endLine;          errorInfo += ", column ";          errorInfo += mode.endColumn;          errorInfo += ".";          errorList.addError(errorInfo);          return;        }        if (continueInfo != null)        {          continueInfo.setResult(QTInfo.size + 2);          continueInfo = null;        }        hasDefault = true;        //记录default的位置，最后一个case跳转
        defaultQuad = QTInfo.size + 2;        info = new QTInfo("J", "_", "_", "WAIT");        qtList.addQTInfo(info);      }    }    ":"    (      StatementBlock()    )*    (      bk = < BREAK > ";"      {        QTInfo breakInfo = new QTInfo("J", "_", "_", "BREAK");        qtList.addQTInfo(breakInfo);        breakChain.mergeTrue(breakInfo);      }    )?    {      if (bk == null)      {        //语句末尾没有break则跳过case判断的两个四元式或default跳转的一个四元式
        continueInfo = new QTInfo("J", "_", "_", "CON");        qtList.addQTInfo(continueInfo);      }      bk = null;    }  )*  "}"  {    if (mode.image == "case" && !hasDefault) info.setResult(QTInfo.size);    else if (mode.image == "case" && hasDefault) info.setResult(defaultQuad);    else if (mode.image == "default")    {      //若default最后出现，则移除default处跳转四元式并将之后的序号前移      qtList.remove(defaultQuad - 1);      qtList.changeIndex(defaultQuad, 1);      QTInfo.size--;    }    breakChain.backpatchTrueChain(QTInfo.size);    //移除最后一个break或continueInfo的跳转四元式    qtList.remove(QTInfo.size);    QTInfo.size--;  }}ConditionValue Logical() :{  ConditionValue chain1 = new ConditionValue();  ConditionValue chain2 = new ConditionValue();  Token log = null;}{  chain1 = Condition()  (    (      log = < AND >      {        chain1.backpatchTrueChain(QTInfo.size + 1);      }    | log = < OR >      {        chain1.backpatchFalseChain(QTInfo.size + 1);      }    )    chain2 = Logical()    {      if (log.image == "&&")      {        chain2.mergeFalse(chain1);      }      else if (log.image == "||")      {        chain2.mergeTrue(chain1);      }      return chain2;    }  )?  {    return chain1;  }}ConditionValue Condition() :{  String e1;  String e2 = null;  String rop = null;  ConditionValue chain = new ConditionValue();}{  e1 = Expression()  (    rop = Relation() e2 = Expression()  )?  {    if (rop != null)    {      QTInfo info = new QTInfo("J" + rop, e1, e2, "T");      qtList.addQTInfo(info);      chain.mergeTrue(info);    }    else    {      QTInfo info = new QTInfo("Jnz", e1, "_", "T");      qtList.addQTInfo(info);      chain.mergeTrue(info);    }    QTInfo info = new QTInfo("J", "_", "_", "F");    qtList.addQTInfo(info);    chain.mergeFalse(info);    return chain;  }}String Expression() :{  String str;}{  str = AdditiveExpression()  {    return str;  }}String AdditiveExpression() :{  String first;  String middle;  String newTemp;  Token op = null;}{  first = MultiplicativeExpression()  {    newTemp = first;  }  (    (      op = < PLUS >    | op = < MINUS >    )    middle = MultiplicativeExpression()    {      newTemp = VariableNameGenerator.genVariableName();      QTInfo qt = new QTInfo(op.image, first, middle, newTemp);      qtList.addQTInfo(qt);      first = newTemp;    }  )*  {    return newTemp;  }}String MultiplicativeExpression() :{  String first;  String middle;  String newTemp;  Token op = null;}{  first = UnaryExpression()  {    newTemp = first;  }  (    (      op = < MULTIPLY >    | op = < DIVIDE >    | op = < MOD >    )    middle = UnaryExpression()    {      newTemp = VariableNameGenerator.genVariableName();      QTInfo qt = new QTInfo(op.image, first, middle, newTemp);      qtList.addQTInfo(qt);      first = newTemp;    }  )*  {    return newTemp;  }}String UnaryExpression() :{  String str = null;  Token t = null;}{  "(" str = Expression() ")"  {    return str;  }| t = < IDENTIFIER >  {
    str = t.image;
    if (argList.checkUndefined(str))
    {
      String errorInfo = "";
      errorInfo += "Variable \"";
      errorInfo += t.image;
      errorInfo += "\" are not declared at line ";
      errorInfo += t.endLine;
      errorInfo += ", column ";
      errorInfo += t.endColumn;
      errorInfo += ".";
      errorList.addError(errorInfo);
    }    return str;  }| t = < INTEGER_LITERAL >  {    str = t.image;    return str;  }| t = < FLOAT_LITERAL >  {    str = t.image;    return str;  }}String Relation() :{  Token t = null;}{  t = < RELATION >  {    return t.image;  }}
